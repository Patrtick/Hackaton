<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<title>Terraform JSON-lines Log Viewer</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body { font-family: Inter, Roboto, Arial, sans-serif; margin: 18px; color:#111; }
  header { display:flex; gap:12px; align-items:center; margin-bottom:12px; }
  input[type=file] { padding:6px; }
  .controls { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .btn { padding:6px 10px; border-radius:6px; border:1px solid #ccc; background:#fff; cursor:pointer; }
  .btn:active{transform:translateY(1px)}
  table { width:100%; border-collapse:collapse; margin-top:12px; font-size:13px; }
  th, td { text-align:left; padding:8px; border-bottom:1px solid #eee; vertical-align:top; }
  th { background:#fafafa; position:sticky; top:0; z-index:2; }
  tbody tr:hover { background:#fbfbff; }
  .level { font-weight:600; padding:2px 6px; border-radius:6px; display:inline-block; font-size:12px; }
  .level-trace { color:#6b7280; background:#f3f4f6; }
  .level-debug { color:#0ea5e9; background:#ecfeff; }
  .level-info  { color:#065f46; background:#ecfdf5; }
  .level-warn  { color:#92400e; background:#fff7ed; }
  .level-error { color:#991b1b; background:#ffefef; }
  .muted { color:#6b7280; font-size:12px; }
  .msg { white-space:pre-wrap; font-family:monospace; }
  .section { padding:8px; border-radius:6px; margin-bottom:8px; background:#f8fafc; border:1px dashed #e6eef8; }
  .section .title { font-weight:700; }
  .json-collapsed { background:#fff; border:1px solid #eee; padding:8px; border-radius:6px; font-family:monospace; font-size:13px; white-space:pre; max-height:220px; overflow:auto; }
  .small { font-size:12px; color:#444 }
  .highlight { outline:2px solid #fde68a; background:#fff7cc; }
  .spinner { width:14px;height:14px;border:2px solid #ddd;border-top-color:#777;border-radius:50%;display:inline-block; animation: spin 1s linear infinite; }
  @keyframes spin { to{transform:rotate(360deg)} }
  .details { font-size:13px; color:#333 }
  .path-input { width:160px; padding:4px 6px; border-radius:4px; border:1px solid #ddd; }

  /* разные стили для plan/apply */
  .section-plan { 
    border: 2px solid #3b82f6; 
    background:#eff6ff;
  }
  .section-apply { 
    border: 2px solid #10b981; 
    background:#ecfdf5;
  }

  .highlight-plan { 
    outline:2px solid #60a5fa; 
    background:#dbeafe !important; 
  }
  .highlight-apply { 
    outline:2px solid #34d399; 
    background:#d1fae5 !important; 
  }

  .badge { 
    display:inline-block; 
    padding:2px 6px; 
    border-radius:6px; 
    font-size:12px; 
    font-weight:600;
  }
  .badge-plan { background:#3b82f6; color:#fff; }
  .badge-apply { background:#10b981; color:#fff; }
</style>
</head>
<body>
<header>
  <div>
    <strong>Terraform JSON-lines Log Viewer</strong>
    <div class="small">Поддерживает эвристическое извлечение timestamp/level, секции plan/apply и ленивое разворачивание JSON тел tf_http_*.</div>
  </div>

  <div style="margin-left:auto" class="controls">
    <input id="fileInput" type="file" accept=".json,.log,.txt" />
    <button id="clearBtn" class="btn">Сброс</button>
  </div>
</header>

<section id="meta"></section>

<section class="controls" style="margin-top:8px; gap:10px;">
  <label class="small">Фильтр уровня:</label>
  <select id="levelFilter" class="path-input">
    <option value="all">Все</option>
    <option value="trace">TRACE</option>
    <option value="debug">DEBUG</option>
    <option value="info">INFO</option>
    <option value="warn">WARN</option>
    <option value="error">ERROR</option>
  </select>

  <label class="small">Поиск (message/module/raw):</label>
  <input id="searchInput" class="path-input" placeholder="строка поиска..." />

  <label class="small">Показывать JSON-тела (по умолчанию скрыты):</label>
  <input id="toggleAllBodies" type="checkbox" />

  <button id="analyzeBtn" class="btn">Анализировать файл</button>
</section>

<!-- sections summary -->
<div id="sectionsContainer" style="margin-top:12px"></div>

<!-- table -->
<div style="margin-top:12px; overflow:auto; max-height:60vh;">
  <table>
    <thead>
      <tr>
        <th style="width:180px">Время</th>
        <th style="width:110px">Уровень</th>
        <th>Сообщение / подсказки</th>
        <th style="width:180px">Модуль / секция</th>
      </tr>
    </thead>
    <tbody id="logTable"></tbody>
  </table>
</div>

<script>
/* ---------- эвристики и регексы ---------- */
const TS_RE = /(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|[+\-]\d{2}:\d{2})?)/;
const LEVEL_RE = /\b(trace|debug|info|warn|warning|error|fatal)\b/i;
/* ключевые слова для описания секций plan/apply — расширяемый список */
const SECTION_START_KEYWORDS = [
  /starting.*\b(plan|apply)\b/i,
  /\b(plan|apply) operation\b/i,
  /^\s*Plan:/i,
  /\bterraform plan\b/i
];
const SECTION_END_KEYWORDS = [
  /\bApply complete\b/i,
  /\bapply complete\b/i,
  /^\s*Plan:.*to add.*to change.*to destroy/i,
  /\bPlan:.*to add/i,
  /\bend of plan/i
];

/* для больших файлов — парсим и добавляем партиями */
const BATCH_SIZE = 500; // строк за интервал

/* ---------- UI refs ---------- */
const fileInput = document.getElementById('fileInput');
const analyzeBtn = document.getElementById('analyzeBtn');
const logTable = document.getElementById('logTable');
const metaDiv = document.getElementById('meta');
const sectionsContainer = document.getElementById('sectionsContainer');
const levelFilter = document.getElementById('levelFilter');
const searchInput = document.getElementById('searchInput');
const clearBtn = document.getElementById('clearBtn');
const toggleAllBodies = document.getElementById('toggleAllBodies');

let parsedLogs = []; // { timestamp, level, message, module, raw, tfSection, bodies: {req,res} }

/* ---------- события ---------- */
clearBtn.addEventListener('click', () => {
  parsedLogs = []; logTable.innerHTML=''; metaDiv.innerHTML=''; sectionsContainer.innerHTML='';
  fileInput.value = '';
});
analyzeBtn.addEventListener('click', readAndParseFile);
levelFilter.addEventListener('change', renderTable);
searchInput.addEventListener('input', debounce(renderTable, 250));
toggleAllBodies.addEventListener('change', () => {
  document.querySelectorAll('.body-toggle')?.forEach(btn => {
    if (toggleAllBodies.checked && btn.dataset.state === 'hidden') btn.click();
    if (!toggleAllBodies.checked && btn.dataset.state === 'shown') btn.click();
  });
});

/* also allow auto analyze on select */
fileInput.addEventListener('change', () => {
  if (fileInput.files && fileInput.files.length) {
    // можно сразу — но оставлю по явному нажатию кнопки
    // readAndParseFile();
  }
});

/* ---------- чтение и парсинг ---------- */
function readAndParseFile() {
  const f = fileInput.files && fileInput.files[0];
  if (!f) { alert('Выберите файл с логом (.json).'); return; }

  parsedLogs = [];
  logTable.innerHTML = '';
  metaDiv.innerHTML = `<div class="small">Чтение файла <strong>${escapeHtml(f.name)}</strong> — ${f.size} байт... <span class="spinner"></span></div>`;

  const reader = new FileReader();
  reader.onload = async (e) => {
    const text = e.target.result;
    // разделяем по строкам. учтём разные окончания строк
    const lines = text.split(/\r?\n/);
    metaDiv.innerHTML = `<div class="small">Проанализировано строк: ${lines.length}</div>`;
    // парсим партиями чтобы UI не завис
    for (let i=0; i < lines.length; i += BATCH_SIZE) {
      const chunk = lines.slice(i, i + BATCH_SIZE);
      processChunk(chunk);
      await sleep(0); // yield
    }
    postProcessSections();
    renderSectionsSummary();
    renderTable();
    metaDiv.innerHTML += `<div class="small" style="margin-top:6px">Готово. Записей: ${parsedLogs.length}</div>`;
  };
  reader.onerror = () => alert('Ошибка чтения файла');
  reader.readAsText(f);
}

function processChunk(lines) {
  for (const rawLine of lines) {
    if (!rawLine || !rawLine.trim()) continue;
    let parsed = tryParseJSON(rawLine);
    if (parsed) {
      // стандартный json-lines формат (как у тебя)
      const ts = parsed['@timestamp'] || findTimestampInRaw(rawLine);
      const lvl = parsed['@level'] || findLevelInRaw(rawLine);
      const mod = parsed['@module'] || parsed['module'] || parsed['@caller'] || '';
      const msg = parsed['@message'] || parsed['message'] || inferMessageFromObject(parsed) || rawLine;
      const bodies = extractBodiesFromObject(parsed); // не парсим JSON тела здесь — только сохраняем строку
      parsedLogs.push({timestamp:ts, level:normalizeLevel(lvl), message:msg, module:mod, raw:rawLine, parsedObj:parsed, bodies});
    } else {
      // не JSON — попытка эвристического вытаскивания ts/level/msg
      const ts = findTimestampInRaw(rawLine);
      const lvl = findLevelInRaw(rawLine);
      const msg = inferMessageFromText(rawLine);
      parsedLogs.push({timestamp:ts, level:normalizeLevel(lvl), message:msg, module:'', raw:rawLine, parsedObj:null, bodies:{}});
    }
  }
}

/* ---------- вспомогательные эвристики ---------- */
function tryParseJSON(line) {
  try {
    return JSON.parse(line);
  } catch(e) {
    return null;
  }
}

function findTimestampInRaw(s) {
  const m = s.match(TS_RE);
  return m ? m[1] : '';
}

function findLevelInRaw(s) {
  const m = s.match(LEVEL_RE);
  return m ? m[1] : '';
}

function normalizeLevel(l) {
  if (!l) return '';
  l = String(l).toLowerCase();
  if (l === 'warning') l = 'warn';
  if (['trace','debug','info','warn','error','fatal'].includes(l)) return l;
  return l;
}

function inferMessageFromObject(obj) {
  if (obj['@message']) return obj['@message'];
  if (obj['message']) return obj['message'];
  const keys = Object.keys(obj).filter(k => !k.startsWith('@')).slice(0,3);
  return keys.length ? keys.map(k => `${k}=${summarize(obj[k])}`).join(' | ') : JSON.stringify(obj).slice(0,200);
}

function inferMessageFromText(s) {
  let t = s.replace(TS_RE, '').replace(LEVEL_RE, '');
  return t.length > 400 ? t.slice(0,400) + '...' : t;
}

function summarize(v) {
  if (v === null) return 'null';
  if (typeof v === 'object') return JSON.stringify(v).slice(0,60);
  return String(v).slice(0,60);
}

/* извлечение полей tf_http_req_body, tf_http_res_body */
function extractBodiesFromObject(obj) {
  const bodies = {};
  for (const k of Object.keys(obj || {})) {
    if (/tf_http_(req|res)_body/i.test(k)) {
      bodies[k] = obj[k];
    }
  }
  return bodies;
}

/* ---------- секции plan/apply ---------- */
function postProcessSections() {
  let currentSection = null;
  parsedLogs.forEach((entry, idx) => {
    const line = (entry.parsedObj && entry.parsedObj['@message']) ? entry.parsedObj['@message'] : entry.message || entry.raw;
    if (!currentSection) {
      if (SECTION_START_KEYWORDS.some(r => r.test(line))) {
        currentSection = { type: determineSectionType(line), startIdx: idx, endIdx: null };
      }
    } else {
      if (SECTION_END_KEYWORDS.some(r => r.test(line))) {
        currentSection.endIdx = idx;
        labelSection(currentSection);
        currentSection = null;
      }
    }
  });
  if (currentSection) {
    currentSection.endIdx = parsedLogs.length - 1;
    labelSection(currentSection);
  }
}

function determineSectionType(line) {
  if (/\bplan\b/i.test(line) && !/\bapply\b/i.test(line)) return 'plan';
  if (/\bapply\b/i.test(line) && !/\bplan\b/i.test(line)) return 'apply';
  return /plan/i.test(line) ? 'plan' : 'apply';
}

function labelSection(section) {
  for (let i = section.startIdx; i <= section.endIdx; i++) {
    parsedLogs[i].tfSection = { type: section.type, start: section.startIdx, end: section.endIdx };
  }
}

/* ---------- рендеринг секций ---------- */
function renderSectionsSummary() {
  sectionsContainer.innerHTML = '';
  const groups = {};
  parsedLogs.forEach((p) => {
    if (p.tfSection) {
      const key = `${p.tfSection.type}:${p.tfSection.start}-${p.tfSection.end}`;
      groups[key] = groups[key] || { type: p.tfSection.type, start: p.tfSection.start, end: p.tfSection.end, count:0 };
      groups[key].count++;
    }
  });
  const keys = Object.keys(groups);
  if (!keys.length) {
    sectionsContainer.innerHTML = '<div class="section small">Секции plan/apply не найдены.</div>';
    return;
  }
  for (const k of keys) {
    const g = groups[k];
    const el = document.createElement('div');
    el.className = 'section section-' + g.type;
    el.innerHTML = `
      <div class="title">
        <span class="badge badge-${g.type}">${g.type.toUpperCase()}</span>
        — строки ${g.start + 1}..${g.end + 1} (записей: ${g.count})
      </div>
      <div class="small">Нажмите «Показать» чтобы подсветить эту секцию в таблице</div>
      <div style="margin-top:6px"><button class="btn" data-range="${g.start},${g.end}">Показать</button></div>`;
    sectionsContainer.appendChild(el);
    el.querySelector('button').addEventListener('click', (ev) => {
      const [s,e] = ev.target.dataset.range.split(',').map(Number);
      highlightRange(s,e);
      const row = document.querySelector(`tr[data-idx="${s}"]`);
      if (row) row.scrollIntoView({behavior:'smooth', block:'center'});
    });
  }
}

function highlightRange(start, end) {
  document.querySelectorAll('tr').forEach(r => {
    r.classList.remove('highlight-plan','highlight-apply');
  });
  const type = parsedLogs[start]?.tfSection?.type;
  const highlightClass = type === 'apply' ? 'highlight-apply' : 'highlight-plan';
  for (let i=start; i<=end; i++) {
    const tr = document.querySelector(`tr[data-idx="${i}"]`);
    if (tr) tr.classList.add(highlightClass);
  }
}

/* ---------- рендер таблицы ---------- */
function renderTable() {
  const lvl = levelFilter.value;
  const q = (searchInput.value || '').toLowerCase();
  logTable.innerHTML = '';
  let count = 0;
  for (let i=0; i<parsedLogs.length; i++) {
    const e = parsedLogs[i];
    if (lvl !== 'all' && e.level !== lvl) continue;
    if (q) {
      const hay = ((e.message||'') + ' ' + (e.module||'') + ' ' + (e.raw||'')).toLowerCase();
      if (!hay.includes(q)) continue;
    }
    count++;
    const tr = document.createElement('tr');
    tr.dataset.idx = i;
    tr.innerHTML = `
      <td class="muted">${escapeHtml(e.timestamp||'')}</td>
      <td>${renderLevelBadge(e.level)}</td>
      <td class="msg">${escapeHtml(e.message||'')}${renderBodies(e)}</td>
      <td class="muted">${escapeHtml(e.module||'')}${renderSectionBadge(e.tfSection)}</td>`;
    logTable.appendChild(tr);
  }
  if (!count) {
    logTable.innerHTML = '<tr><td colspan=4 class="small">Нет совпадений по фильтру/поиску.</td></tr>';
  }
}

function renderLevelBadge(lvl) {
  if (!lvl) return '';
  return `<span class="level level-${lvl}">${lvl.toUpperCase()}</span>`;
}

function renderSectionBadge(sec) {
  if (!sec) return '';
  return `<div><span class="badge badge-${sec.type}">${sec.type.toUpperCase()}</span></div>`;
}

function renderBodies(entry) {
  const keys = Object.keys(entry.bodies || {});
  if (!keys.length) return '';
  let html = '';
  for (const k of keys) {
    html += `<div>
      <button class="btn body-toggle" data-state="hidden" data-key="${k}">Показать ${escapeHtml(k)}</button>
      <div class="json-collapsed" style="display:none"></div>
    </div>`;
  }
  return html;
}

/* события для кнопок body-toggle */
document.addEventListener('click', (ev) => {
  const btn = ev.target.closest('.body-toggle');
  if (!btn) return;
  const key = btn.dataset.key;
  const tr = btn.closest('tr');
  const idx = parseInt(tr.dataset.idx,10);
  const entry = parsedLogs[idx];
  const div = btn.nextElementSibling;
  if (btn.dataset.state === 'hidden') {
    let val = entry.bodies[key];
    try {
      const parsed = JSON.parse(val);
      val = JSON.stringify(parsed, null, 2);
    } catch(e) {}
    div.textContent = val;
    div.style.display = 'block';
    btn.textContent = 'Скрыть ' + key;
    btn.dataset.state = 'shown';
  } else {
    div.style.display = 'none';
    btn.textContent = 'Показать ' + key;
    btn.dataset.state = 'hidden';
  }
});

/* ---------- утилиты ---------- */
function escapeHtml(s) {
  return s ? s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])) : '';
}

function debounce(fn, ms) {
  let t;
  return function(...args) {
    clearTimeout(t);
    t = setTimeout(() => fn.apply(this, args), ms);
  }
}

function sleep(ms) {
  return new Promise(res => setTimeout(res, ms));
}
</script>
</body>
</html>
